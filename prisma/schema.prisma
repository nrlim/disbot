generator client {
  provider = "prisma-client-js"
}

generator client_worker {
  provider = "prisma-client-js"
  output   = "../worker/node_modules/.prisma/client"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId], name: "provider_providerAccountId")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id               String            @id @default(cuid())
  name             String?
  email            String?           @unique
  emailVerified    DateTime?
  image            String?
  plan             Plan              @default(FREE)
  packageExpiredAt DateTime?
  accounts         Account[]
  discordAccounts  DiscordAccount[]
  configs          MirrorConfig[]
  sessions         Session[]
  telegramAccounts TelegramAccount[]
  botConfigs       BotConfig[]

  mirrorGroups     MirrorGroup[]
  payments         PaymentHistory[]
}

model PaymentHistory {
  id        String   @id @default(cuid())
  userId    String
  orderId   String   @unique
  amount    Float
  plan      Plan
  status    String   @default("pending") // pending, success, failed, challenge
  snapToken String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model MirrorConfig {
  id                String           @id @default(cuid())
  sourcePlatform    PlatformType     @default(DISCORD)
  type              MirrorType       @default(CUSTOM_HOOK)
  active            Boolean          @default(true)
  status            String           @default("ACTIVE")
  sourceGuildName   String?
  sourceChannelId   String?
  discordAccountId  String?
  telegramAccountId String?
  targetWebhookUrl  String?
  targetWebhookName String?
  targetChannelId   String?
  userId            String
  groupId           String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  lastActiveAt      DateTime?
  name              String?
  sourceChannelName String?
  targetChannelName String?
  targetGuildId     String?
  targetGuildName   String?
  telegramTopicId   String?
  sourceGuildId     String?
  customWatermark   String?
  watermarkType     WatermarkType @default(TEXT)
  watermarkImageUrl String?
  watermarkPosition String?       @default("southeast")
  watermarkOpacity  Int?          @default(100)
  brandColor        String?
  blurRegions       Json?
  antiSpamEnabled   Boolean       @default(true)
  blacklistedUsers  Json?         @default("[]")
  // Legacy fields (for backward compatibility / migration)
  telegramSession   String?
  telegramChatId    String?
  userToken         String?
  discordAccount    DiscordAccount?  @relation(fields: [discordAccountId], references: [id])
  telegramAccount   TelegramAccount? @relation(fields: [telegramAccountId], references: [id])
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  group             MirrorGroup?     @relation(fields: [groupId], references: [id])

  @@index([userId])
  @@index([sourcePlatform])
  @@index([discordAccountId])
  @@index([telegramAccountId])
  @@index([groupId])
}

model MirrorGroup {
  id      String          @id @default(cuid())
  name    String
  type    MirrorGroupType @default(DISCORD_TO_DISCORD)
  active  Boolean         @default(true)
  userId  String
  user    User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  configs MirrorConfig[]

  @@index([userId])
}

model DiscordAccount {
  id            String         @id @default(cuid())
  userId        String
  discordId     String?
  username      String
  discriminator String?
  avatar        String?
  token         String
  valid         Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  mirrorConfigs MirrorConfig[]

  @@index([userId])
}

model TelegramAccount {
  id            String         @id @default(cuid())
  userId        String
  telegramId    String?
  username      String?
  firstName     String?
  lastName      String?
  photoUrl      String?
  phone         String
  sessionString String
  valid         Boolean        @default(true)
  cachedChannel Json?          // Cached chat/channel list
  cachedAt      DateTime?      // When channels were cached
  cachedTopics  Json?          // Cache: { [chatId]: { topics: [], cachedAt: date } }
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  mirrorConfigs MirrorConfig[]
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ──────────────────────────────────────────────────────────────
// Discord Role Manager Models
// ──────────────────────────────────────────────────────────────

model Package {
  id       String      @id @default(cuid())
  name     String      @unique // e.g., 'BASIC', 'PRO', 'ELITE'
  features String[]    // ['GRANT', 'CHECK', 'EXTEND', 'REVOKE']
  bots     BotConfig[]
}

model BotConfig {
  id          String   @id @default(cuid())
  name        String?  // Custom bot name
  userId      String?
  user        User?    @relation(fields: [userId], references: [id])
  packageId   String?
  package     Package? @relation(fields: [packageId], references: [id])
  features    String[] // Individual enabled features

  botToken    String                        // Discord Bot Token (encrypted)
  clientId    String                        // Discord Application Client ID
  guildId     String                        // Primary Guild ID to manage
  adminRoleId String?                       // Role ID that can manage the bot
  trialRoleId String?                       // Role to assign when premium expires
  active      Boolean  @default(true)       // Enable/disable the manager bot
  globalAntiSpam Boolean @default(true)     // Enable/disable flood detection globally
  
  lastWorkerHeartbeat  DateTime?
  lastManagerHeartbeat DateTime?
  restartWorkerAt      DateTime?
  restartManagerAt     DateTime?
  earningChannels      String[]      // Whitelisted Discord channel IDs
  pointConfig PointConfig?
  redeemItems RedeemItem[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId])
}

model PointConfig {
  id               String    @id @default(cuid())
  botId            String    @unique
  botConfig        BotConfig @relation(fields: [botId], references: [id], onDelete: Cascade)
  pointsPerMessage Int       @default(1)
  cooldownSeconds  Int       @default(60)
  redeemRules      Json      @default("[]") // Array of { cost: number, roleId: string, durationDays: number }

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
}

model RedeemItem {
  id           String    @id @default(cuid())
  botId        String
  botConfig    BotConfig @relation(fields: [botId], references: [id], onDelete: Cascade)
  roleId       String
  roleName     String
  pointCost    Int
  durationDays Int
  isActive     Boolean   @default(true)

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([botId])
}

model SpamBlacklist {
  id         String   @id @default(cuid())
  telegramId String   @unique               // Blocked Telegram ID
  reason     String                          // 'Auto' or 'Manual'
  createdAt  DateTime @default(now())
}

model DiscordUser {
  id          String     @id @default(cuid())
  discordId   String
  guildId     String
  currentRole String
  expiryDate  DateTime
  status      RoleStatus @default(ACTIVE)
  points      Int        @default(0)
  totalMessages Int      @default(0)
  assignedAt  DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@unique([discordId, guildId], name: "discordId_guildId")
  @@index([expiryDate])
  @@index([guildId])
  @@index([status])
}

enum RoleStatus {
  ACTIVE
  EXPIRED
}

// ──────────────────────────────────────────────────────────────
// Core Enums
// ──────────────────────────────────────────────────────────────

enum Plan {
  FREE
  STARTER
  PRO
  ELITE
}

enum MirrorType {
  CUSTOM_HOOK
  MANAGED_BOT
}

enum PlatformType {
  DISCORD
  TELEGRAM
}

enum MirrorGroupType {
  DISCORD_TO_DISCORD
  TELEGRAM_TO_DISCORD
  DISCORD_TO_TELEGRAM
  TELEGRAM_TO_TELEGRAM
}

enum WatermarkType {
  TEXT
  VISUAL
}
