generator client {
  provider = "prisma-client-js"
}

generator client_worker {
  provider = "prisma-client-js"
  output   = "../worker/node_modules/.prisma/client"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId], name: "provider_providerAccountId")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id               String            @id @default(cuid())
  name             String?
  email            String?           @unique
  emailVerified    DateTime?
  image            String?
  plan             Plan              @default(FREE)
  packageExpiredAt DateTime?
  accounts         Account[]
  discordAccounts  DiscordAccount[]
  configs          MirrorConfig[]
  sessions         Session[]
  telegramAccounts TelegramAccount[]

  mirrorGroups     MirrorGroup[]
  payments         PaymentHistory[]
}

model PaymentHistory {
  id        String   @id @default(cuid())
  userId    String
  orderId   String   @unique
  amount    Float
  plan      Plan
  status    String   @default("pending") // pending, success, failed, challenge
  snapToken String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model MirrorConfig {
  id                String           @id @default(cuid())
  sourcePlatform    PlatformType     @default(DISCORD)
  type              MirrorType       @default(CUSTOM_HOOK)
  active            Boolean          @default(true)
  status            String           @default("ACTIVE")
  sourceGuildName   String?
  sourceChannelId   String?
  discordAccountId  String?
  telegramAccountId String?
  targetWebhookUrl  String?
  targetWebhookName String?
  targetChannelId   String?
  userId            String
  groupId           String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  lastActiveAt      DateTime?
  name              String?
  sourceChannelName String?
  targetChannelName String?
  targetGuildId     String?
  targetGuildName   String?
  telegramTopicId   String?
  sourceGuildId     String?
  // Legacy fields (for backward compatibility / migration)
  telegramSession   String?
  telegramChatId    String?
  userToken         String?
  discordAccount    DiscordAccount?  @relation(fields: [discordAccountId], references: [id])
  telegramAccount   TelegramAccount? @relation(fields: [telegramAccountId], references: [id])
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  group             MirrorGroup?     @relation(fields: [groupId], references: [id])

  @@index([userId])
  @@index([sourcePlatform])
  @@index([discordAccountId])
  @@index([telegramAccountId])
  @@index([groupId])
}

model MirrorGroup {
  id      String          @id @default(cuid())
  name    String
  type    MirrorGroupType @default(DISCORD_TO_DISCORD)
  active  Boolean         @default(true)
  userId  String
  user    User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  configs MirrorConfig[]

  @@index([userId])
}

model DiscordAccount {
  id            String         @id @default(cuid())
  userId        String
  discordId     String?
  username      String
  discriminator String?
  avatar        String?
  token         String
  valid         Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  mirrorConfigs MirrorConfig[]

  @@index([userId])
}

model TelegramAccount {
  id            String         @id @default(cuid())
  userId        String
  telegramId    String?
  username      String?
  phone         String
  sessionString String
  valid         Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  mirrorConfigs MirrorConfig[]
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum Plan {
  FREE
  STARTER
  PRO
  ELITE
}

enum MirrorType {
  CUSTOM_HOOK
  MANAGED_BOT
}

enum PlatformType {
  DISCORD
  TELEGRAM
}

enum MirrorGroupType {
  DISCORD_TO_DISCORD
  TELEGRAM_TO_DISCORD
}
